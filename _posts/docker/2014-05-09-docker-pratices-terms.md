---
title: 'Docker实战： 三、基本概念与术语'
summary: "在进行下一步实际演练之前，我们还需要搞清楚与Docker有关的一些基本概念。"
tags: Docker 服务器
category: 服务器
series: Docker实战
layout: post
---

{% assign align='right' %}
{% assign src='/docker/docker-top-logo.png' %}
{% include image.html %}


在前一章中，我们创建了一个Ubuntu虚拟机，并在这个虚拟机上安装了Docker服务器。于是，我们有了一个正在运行着的Docker服务器，还有一个名为docker的命令行客户端用于与Docker服务进行交互。

现在你肯定已经跃跃欲试的想在命令行上输入点什么了。但是请先等一下，在进行下一步实际演练之前，我们还需要搞清楚一些基本的概念。

{% series_list %}

##容器（Container）

****

Docker自称是一个**容器**引擎。那么这个**“容器”**到底是什么意思呢？

我们知道，Docker最基础的能力就是能将一个应用打包成一个可以独立运行的、便携式的容器。这里“独立”的意思是除Docker自身外没有第三方软件依赖并且与其它容器完全隔离。“便携”的意思则是说容器可以在任何支持Docker的主机上自由的迁移，无论此主机是物理机器还是虚拟机，也无论是哪个Linux发行版本。在多台主机上分发与运行一个打包好的应用就像发动汽车那样简单。

这听起来有些不可思议，因为一个应用的运行环境包括大量的外部依赖。就拿一个最简单的Web应用来说，就包括了指定版本的操作系统、相应语言环境或运行时库(Java、Ruby、PHP...)、数据库及其驱动(Oracle、Mysql、 Mongodb...)、HTTP服务器(Apache、Nginx...)、第三方软件包等等。另外，还需要大量特定的配置，如操作系统用户及组配置、目录权限设置、日志管理、网络端口配置等等。在传统的部署模式中，即使应用了自动配置工具如Puppet、Chef等，要在一台新机器上发布一个应用还是一件费时费力的工作。要是多个应用部署在一台主机上，那各种软件版本冲突、资源分配与协调等工作更是让人头疼。

为了解决这个问题，Docker使用了类似虚拟机的技术，将OS、应用程序及其依赖软件、配置信息等都写入一个镜像（Image）文件. 但与普通虚拟机不同的是，这个Image的文件系统是只读的。也就说，打包一旦完成，那么里面所有内容都不可更改了。

在启动一个镜像时，Docker首先读取这个镜像，然后在其上面再增加一个可读写层。这个可读写层，加上它所有的父镜像和诸如网络配置、唯一编码、内存与cpu限制等附加信息，被称为一个 **容器（Container）**。

从面向对象的角度来看，可以把镜像视为类，容器则是这个类的实例。一个镜像可以产生出多个容器，而一个容器只能基于一个镜像创建。

### 容器的状态

容器具有“running”与"exited"两个状态。

一个处于running状态的容器，除了包含前述的文件系统内容和附加信息外，还包括了所有运行中的进程树。这棵进程树与主机上运行的其它进程是相互隔离的。

当容器内的进程运行结束，或者用户手工停止或杀死这个容器时，容器就处于“exited”状态。所有在容器运行时对文件系统的更改都将被保留，但内存状态将会丢失。我们可以稍后再次启动这个容器。

### 容器ID与命名

每一个容器都有一个唯一的ID，这个ID是一个由64个16进制字符组成的字符串。为了方便在命令中引用，我们一般只需使用前12个字符即可。

为了更加便于记忆与引用，在创建容器时，我们也可以给容器命名，比如给将一个Mongodb容器命名为“mg-server“，或者将一个FTP容器命名为“my-file-server”等等。容器的名称可以随意指定，只要保证在这台主机上是唯一的即可。

## 镜像 (Image)

****

在Docker的术语中，镜像表示一个只读的文件系统层。

Docker使用了一种被称为“联合文件系统 (Union File System)”的技术来创建容器。整个容器被视为拥有一个可读写的文件系统，但实际在内部，所有的修改操作都只是发生在最上面的可读写层，在下层的只读镜像中的原始文件是永远不变的。因为镜像不能被修改，所以它也没有状态。

### 父镜像（Parent Image）

除了基础镜像外，所有其它的镜像都是基于其它一个或多个镜像创建的。这些镜像被称为这个镜像的父镜像。每个镜像实际上只存储了相对于父镜像的变化部分。通过这样的技术，不同的应用容器可以共享相同的父镜像，极大的节约了系统资源。

### 基础镜像（Base Image）

没有任何父镜像的层称为基础镜像。绝大多数基础镜像都是包含了最基本的操作系统的镜像。在docker的中心注册库中包含了大多数流行的Linux发行版本的基础镜像。

### 镜像ID

每一个镜像都有一个唯一的ID，这个ID是一个由64个16进制字符组成的字符串。为了方便在命令中引用，我们一般只需使用前12个字符即可。

## 仓库（Repository）
****
一个仓库代表了一系列镜像的逻辑集合。

为了方便的对镜像进行引用与版本管理，我们一般会把同一类镜像与一个仓库名称关联。在仓库中则使用标签（tag）来指向特定的镜像。

可以把仓库视为某一类镜像的共同名称，而tag则是指向某一具体镜像的指针。

在使用仓库名称引用镜像时，需要指定标签，如果没有给出标签名，则默认为**latest**.

举例来说，假设我们开发了一个名为“new_app”的应用并创建了一个当前版本的镜像文件。我们现在可以把这个镜像文件与仓库名称“new_app_repo”关联(关联方法在下一节说明)。现在这个名为"new_app_repo"的仓库就保存了这个镜像及其所有父镜像的ID，并且创建了一个名为“latest”的标签，指向最新的那个镜像ID。过了几天，我们发布了new_app的新版本程序，并重新创建了最新版本的镜像文件。这时我们可以先把旧的镜像关联至“new_app_repo:old_version”这个标签，然后将新镜像关联至“new_app_repo:latest”。这样一来，我们的仓库“new_app_repo”就包含了应用"new_app"的所有版本，并且其默认标签“lastest”总是指向最新的应用程序版本。

但在实际上，一个仓库内的镜像并不需要有实际的关联，我们完全可以把属于不同应用的镜像关联至同一个仓库，只是这样做似乎没有什么实际用处。

### 关联镜像至仓库名

目前有三种方法可以将一个镜像与仓库名关联：

1. 在构建时指定，如: docker build -t 镜像名称
2. 在提交一个容器至镜像时，如： docker commit 容器ID 镜像名称
3. 在为一个镜像ID打标签时，如： docker tag 镜像ID 镜像名称

这里的镜像名称是指完全限定的镜像名（Fully Qualified Image Name (FQIN) 由三部分组成：

```
[registry_hostname[:port]/][user_name/](repository_name[:version_tag])
[注册库主机名:[端口]]/][用户名/]([仓库名][:版本标签])
```
其中只有仓库名是必须的。注册库默认为`index.docker.io:80`。 版本标签默认为`latest`。

如果您创建一个新的仓库并想发布到中心注册库进行分享，那么必须给出用户名，因为默认的'default'用户名是为Docker官方镜像保留的。

## 标签（Tag）
****
标签指向仓库中的某个具体镜像。可以视为镜像在当前仓库中的命名指针。

## 注册库（Resgistry）
****
注册库是一个能响应Registry API的，包含了镜像仓库的托管服务。

默认的注册库位于<https://index.docker.io>。这是一个Docker官方创建的公开注册库。任何人都可以在上面发布及下载共享的镜像。 

您也可以创建私有注册库来托管您公司的私有仓库。

注册库的主要作用是进行镜像的分享。我们可以把自己创建的镜像发布到注册库中，也可以从注册库中获取其他人创建的镜像。